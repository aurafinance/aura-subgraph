"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type Account {
  """
  Address
  
  """
  id: ID!
  poolAccounts(skip: Int = 0, first: Int = 100, orderBy: PoolAccount_orderBy, orderDirection: OrderDirection, where: PoolAccount_filter): [PoolAccount!]!
  cvxLockerAccount: CvxLockerAccount
}

input Account_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cvxLockerAccount: String
  cvxLockerAccount_not: String
  cvxLockerAccount_gt: String
  cvxLockerAccount_lt: String
  cvxLockerAccount_gte: String
  cvxLockerAccount_lte: String
  cvxLockerAccount_in: [String!]
  cvxLockerAccount_not_in: [String!]
  cvxLockerAccount_contains: String
  cvxLockerAccount_contains_nocase: String
  cvxLockerAccount_not_contains: String
  cvxLockerAccount_not_contains_nocase: String
  cvxLockerAccount_starts_with: String
  cvxLockerAccount_starts_with_nocase: String
  cvxLockerAccount_not_starts_with: String
  cvxLockerAccount_not_starts_with_nocase: String
  cvxLockerAccount_ends_with: String
  cvxLockerAccount_ends_with_nocase: String
  cvxLockerAccount_not_ends_with: String
  cvxLockerAccount_not_ends_with_nocase: String
}

enum Account_orderBy {
  id
  poolAccounts
  cvxLockerAccount
}

type AuraLocker {
  """
  Singleton: "AuraLocker"
  
  """
  id: ID!
  address: Bytes!
  rewardData(skip: Int = 0, first: Int = 100, orderBy: AuraLockerRewardData_orderBy, orderDirection: OrderDirection, where: AuraLockerRewardData_filter): [AuraLockerRewardData!]!
}

input AuraLocker_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: Bytes
  address_not: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
}

enum AuraLocker_orderBy {
  id
  address
  rewardData
}

type AuraLockerRewardData implements IRewardData {
  """
  {token.id}
  
  """
  id: ID!
  token: Token!
  periodFinish: Int!
  lastUpdateTime: Int!
  rewardRate: BigInt!
  rewardPerTokenStored: BigInt!
  auraLocker: AuraLocker!
}

input AuraLockerRewardData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  periodFinish: Int
  periodFinish_not: Int
  periodFinish_gt: Int
  periodFinish_lt: Int
  periodFinish_gte: Int
  periodFinish_lte: Int
  periodFinish_in: [Int!]
  periodFinish_not_in: [Int!]
  lastUpdateTime: Int
  lastUpdateTime_not: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_lt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_not_in: [Int!]
  rewardRate: BigInt
  rewardRate_not: BigInt
  rewardRate_gt: BigInt
  rewardRate_lt: BigInt
  rewardRate_gte: BigInt
  rewardRate_lte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_not_in: [BigInt!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_not_in: [BigInt!]
  auraLocker: String
  auraLocker_not: String
  auraLocker_gt: String
  auraLocker_lt: String
  auraLocker_gte: String
  auraLocker_lte: String
  auraLocker_in: [String!]
  auraLocker_not_in: [String!]
  auraLocker_contains: String
  auraLocker_contains_nocase: String
  auraLocker_not_contains: String
  auraLocker_not_contains_nocase: String
  auraLocker_starts_with: String
  auraLocker_starts_with_nocase: String
  auraLocker_not_starts_with: String
  auraLocker_not_starts_with_nocase: String
  auraLocker_ends_with: String
  auraLocker_ends_with_nocase: String
  auraLocker_not_ends_with: String
  auraLocker_not_ends_with_nocase: String
}

enum AuraLockerRewardData_orderBy {
  id
  token
  periodFinish
  lastUpdateTime
  rewardRate
  rewardPerTokenStored
  auraLocker
}

scalar BigDecimal

scalar BigInt

"""The block at which the query should be executed."""
input Block_height {
  """Value containing a block hash"""
  hash: Bytes

  """Value containing a block number"""
  number: Int

  """
  Value containing the minimum block number. 
  In the case of `number_gte`, the query will be executed on the latest block only if
  the subgraph has progressed to or past the minimum block number.
  Defaults to the latest block when omitted.
  
  """
  number_gte: Int
}

scalar Bytes

type CvxCrvPoolData {
  """
  Singleton: "cvxCrv"
  
  """
  id: ID!
  pool: Pool!
  maxSupply: BigInt!
  reductionPerCliff: BigInt!
  totalCliffs: BigInt!
}

input CvxCrvPoolData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  maxSupply: BigInt
  maxSupply_not: BigInt
  maxSupply_gt: BigInt
  maxSupply_lt: BigInt
  maxSupply_gte: BigInt
  maxSupply_lte: BigInt
  maxSupply_in: [BigInt!]
  maxSupply_not_in: [BigInt!]
  reductionPerCliff: BigInt
  reductionPerCliff_not: BigInt
  reductionPerCliff_gt: BigInt
  reductionPerCliff_lt: BigInt
  reductionPerCliff_gte: BigInt
  reductionPerCliff_lte: BigInt
  reductionPerCliff_in: [BigInt!]
  reductionPerCliff_not_in: [BigInt!]
  totalCliffs: BigInt
  totalCliffs_not: BigInt
  totalCliffs_gt: BigInt
  totalCliffs_lt: BigInt
  totalCliffs_gte: BigInt
  totalCliffs_lte: BigInt
  totalCliffs_in: [BigInt!]
  totalCliffs_not_in: [BigInt!]
}

enum CvxCrvPoolData_orderBy {
  id
  pool
  maxSupply
  reductionPerCliff
  totalCliffs
}

type CvxLockerAccount {
  """
  {Account.id}
  
  """
  id: ID!
  account: Account!
  balance: BigInt!

  """
  AuraLocker.balances(account)
  
  """
  balanceLocked: BigInt!
  balanceNextUnlockIndex: Int!

  """
  AuraLocker.rewardData(account)
  
  """
  periodFinish: Int!
  lastUpdateTime: Int!
  rewardRate: BigInt!
  rewardPerTokenPaid: BigInt!

  """
  AuraLocker.userLocks(account)
  
  """
  userLocks(skip: Int = 0, first: Int = 100, orderBy: CvxLockerUserLock_orderBy, orderDirection: OrderDirection, where: CvxLockerUserLock_filter): [CvxLockerUserLock!]!

  """
  AuraLocker.userData(account)
  
  """
  userData(skip: Int = 0, first: Int = 100, orderBy: CvxLockerUserData_orderBy, orderDirection: OrderDirection, where: CvxLockerUserData_filter): [CvxLockerUserData!]!
}

input CvxLockerAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  balanceLocked: BigInt
  balanceLocked_not: BigInt
  balanceLocked_gt: BigInt
  balanceLocked_lt: BigInt
  balanceLocked_gte: BigInt
  balanceLocked_lte: BigInt
  balanceLocked_in: [BigInt!]
  balanceLocked_not_in: [BigInt!]
  balanceNextUnlockIndex: Int
  balanceNextUnlockIndex_not: Int
  balanceNextUnlockIndex_gt: Int
  balanceNextUnlockIndex_lt: Int
  balanceNextUnlockIndex_gte: Int
  balanceNextUnlockIndex_lte: Int
  balanceNextUnlockIndex_in: [Int!]
  balanceNextUnlockIndex_not_in: [Int!]
  periodFinish: Int
  periodFinish_not: Int
  periodFinish_gt: Int
  periodFinish_lt: Int
  periodFinish_gte: Int
  periodFinish_lte: Int
  periodFinish_in: [Int!]
  periodFinish_not_in: [Int!]
  lastUpdateTime: Int
  lastUpdateTime_not: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_lt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_not_in: [Int!]
  rewardRate: BigInt
  rewardRate_not: BigInt
  rewardRate_gt: BigInt
  rewardRate_lt: BigInt
  rewardRate_gte: BigInt
  rewardRate_lte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_not_in: [BigInt!]
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_not_in: [BigInt!]
}

enum CvxLockerAccount_orderBy {
  id
  account
  balance
  balanceLocked
  balanceNextUnlockIndex
  periodFinish
  lastUpdateTime
  rewardRate
  rewardPerTokenPaid
  userLocks
  userData
}

type CvxLockerUserData {
  """
  {CvxLockerAccount.id}.{Token.id}
  
  """
  id: ID!
  cvxLockerAccount: CvxLockerAccount!
  token: ID!
  rewards: BigInt!
  rewardPerTokenPaid: BigInt!
}

input CvxLockerUserData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cvxLockerAccount: String
  cvxLockerAccount_not: String
  cvxLockerAccount_gt: String
  cvxLockerAccount_lt: String
  cvxLockerAccount_gte: String
  cvxLockerAccount_lte: String
  cvxLockerAccount_in: [String!]
  cvxLockerAccount_not_in: [String!]
  cvxLockerAccount_contains: String
  cvxLockerAccount_contains_nocase: String
  cvxLockerAccount_not_contains: String
  cvxLockerAccount_not_contains_nocase: String
  cvxLockerAccount_starts_with: String
  cvxLockerAccount_starts_with_nocase: String
  cvxLockerAccount_not_starts_with: String
  cvxLockerAccount_not_starts_with_nocase: String
  cvxLockerAccount_ends_with: String
  cvxLockerAccount_ends_with_nocase: String
  cvxLockerAccount_not_ends_with: String
  cvxLockerAccount_not_ends_with_nocase: String
  token: ID
  token_not: ID
  token_gt: ID
  token_lt: ID
  token_gte: ID
  token_lte: ID
  token_in: [ID!]
  token_not_in: [ID!]
  rewards: BigInt
  rewards_not: BigInt
  rewards_gt: BigInt
  rewards_lt: BigInt
  rewards_gte: BigInt
  rewards_lte: BigInt
  rewards_in: [BigInt!]
  rewards_not_in: [BigInt!]
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_not_in: [BigInt!]
}

enum CvxLockerUserData_orderBy {
  id
  cvxLockerAccount
  token
  rewards
  rewardPerTokenPaid
}

type CvxLockerUserLock {
  """
  {CvxLockerAccount.id}.{index}
  
  """
  id: ID!
  cvxLockerAccount: CvxLockerAccount!
  amount: BigInt!
  unlockTime: Int!
}

input CvxLockerUserLock_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cvxLockerAccount: String
  cvxLockerAccount_not: String
  cvxLockerAccount_gt: String
  cvxLockerAccount_lt: String
  cvxLockerAccount_gte: String
  cvxLockerAccount_lte: String
  cvxLockerAccount_in: [String!]
  cvxLockerAccount_not_in: [String!]
  cvxLockerAccount_contains: String
  cvxLockerAccount_contains_nocase: String
  cvxLockerAccount_not_contains: String
  cvxLockerAccount_not_contains_nocase: String
  cvxLockerAccount_starts_with: String
  cvxLockerAccount_starts_with_nocase: String
  cvxLockerAccount_not_starts_with: String
  cvxLockerAccount_not_starts_with_nocase: String
  cvxLockerAccount_ends_with: String
  cvxLockerAccount_ends_with_nocase: String
  cvxLockerAccount_not_ends_with: String
  cvxLockerAccount_not_ends_with_nocase: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  unlockTime: Int
  unlockTime_not: Int
  unlockTime_gt: Int
  unlockTime_lt: Int
  unlockTime_gte: Int
  unlockTime_lte: Int
  unlockTime_in: [Int!]
  unlockTime_not_in: [Int!]
}

enum CvxLockerUserLock_orderBy {
  id
  cvxLockerAccount
  amount
  unlockTime
}

type FactoryPoolData {
  """
  {pool.id}
  
  """
  id: ID!
  pool: Pool!
  lpToken: Token!
  gauge: Bytes!
  stash: Bytes!
  isShutdown: Boolean!
}

input FactoryPoolData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  lpToken: String
  lpToken_not: String
  lpToken_gt: String
  lpToken_lt: String
  lpToken_gte: String
  lpToken_lte: String
  lpToken_in: [String!]
  lpToken_not_in: [String!]
  lpToken_contains: String
  lpToken_contains_nocase: String
  lpToken_not_contains: String
  lpToken_not_contains_nocase: String
  lpToken_starts_with: String
  lpToken_starts_with_nocase: String
  lpToken_not_starts_with: String
  lpToken_not_starts_with_nocase: String
  lpToken_ends_with: String
  lpToken_ends_with_nocase: String
  lpToken_not_ends_with: String
  lpToken_not_ends_with_nocase: String
  gauge: Bytes
  gauge_not: Bytes
  gauge_in: [Bytes!]
  gauge_not_in: [Bytes!]
  gauge_contains: Bytes
  gauge_not_contains: Bytes
  stash: Bytes
  stash_not: Bytes
  stash_in: [Bytes!]
  stash_not_in: [Bytes!]
  stash_contains: Bytes
  stash_not_contains: Bytes
  isShutdown: Boolean
  isShutdown_not: Boolean
  isShutdown_in: [Boolean!]
  isShutdown_not_in: [Boolean!]
}

enum FactoryPoolData_orderBy {
  id
  pool
  lpToken
  gauge
  stash
  isShutdown
}

interface IRewardData {
  token: Token!

  """
  Timestamp for current period finish
  
  """
  periodFinish: Int!

  """
  Last time any user took action
  
  """
  lastUpdateTime: Int!

  """
  RewardRate for the rest of the period
  
  """
  rewardRate: BigInt!

  """
  Ever increasing rewardPerToken rate, based on % of total supply
  
  """
  rewardPerTokenStored: BigInt!
}

input IRewardData_filter {
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  periodFinish: Int
  periodFinish_not: Int
  periodFinish_gt: Int
  periodFinish_lt: Int
  periodFinish_gte: Int
  periodFinish_lte: Int
  periodFinish_in: [Int!]
  periodFinish_not_in: [Int!]
  lastUpdateTime: Int
  lastUpdateTime_not: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_lt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_not_in: [Int!]
  rewardRate: BigInt
  rewardRate_not: BigInt
  rewardRate_gt: BigInt
  rewardRate_lt: BigInt
  rewardRate_gte: BigInt
  rewardRate_lte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_not_in: [BigInt!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_not_in: [BigInt!]
}

enum IRewardData_orderBy {
  token
  periodFinish
  lastUpdateTime
  rewardRate
  rewardPerTokenStored
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  """
  Pool ID (pid)
  
  """
  id: ID!
  depositToken: Token!
  rewardPool: Bytes!
  totalSupply: BigInt!
  factoryPoolData: FactoryPoolData
  rewardData(skip: Int = 0, first: Int = 100, orderBy: PoolRewardData_orderBy, orderDirection: OrderDirection, where: PoolRewardData_filter): [PoolRewardData!]!
  accounts(skip: Int = 0, first: Int = 100, orderBy: PoolAccount_orderBy, orderDirection: OrderDirection, where: PoolAccount_filter): [PoolAccount!]!
}

input Pool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  depositToken: String
  depositToken_not: String
  depositToken_gt: String
  depositToken_lt: String
  depositToken_gte: String
  depositToken_lte: String
  depositToken_in: [String!]
  depositToken_not_in: [String!]
  depositToken_contains: String
  depositToken_contains_nocase: String
  depositToken_not_contains: String
  depositToken_not_contains_nocase: String
  depositToken_starts_with: String
  depositToken_starts_with_nocase: String
  depositToken_not_starts_with: String
  depositToken_not_starts_with_nocase: String
  depositToken_ends_with: String
  depositToken_ends_with_nocase: String
  depositToken_not_ends_with: String
  depositToken_not_ends_with_nocase: String
  rewardPool: Bytes
  rewardPool_not: Bytes
  rewardPool_in: [Bytes!]
  rewardPool_not_in: [Bytes!]
  rewardPool_contains: Bytes
  rewardPool_not_contains: Bytes
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  factoryPoolData: String
  factoryPoolData_not: String
  factoryPoolData_gt: String
  factoryPoolData_lt: String
  factoryPoolData_gte: String
  factoryPoolData_lte: String
  factoryPoolData_in: [String!]
  factoryPoolData_not_in: [String!]
  factoryPoolData_contains: String
  factoryPoolData_contains_nocase: String
  factoryPoolData_not_contains: String
  factoryPoolData_not_contains_nocase: String
  factoryPoolData_starts_with: String
  factoryPoolData_starts_with_nocase: String
  factoryPoolData_not_starts_with: String
  factoryPoolData_not_starts_with_nocase: String
  factoryPoolData_ends_with: String
  factoryPoolData_ends_with_nocase: String
  factoryPoolData_not_ends_with: String
  factoryPoolData_not_ends_with_nocase: String
}

enum Pool_orderBy {
  id
  depositToken
  rewardPool
  totalSupply
  factoryPoolData
  rewardData
  accounts
}

type PoolAccount {
  """
  {Pool.id}.{Account.id}
  
  """
  id: ID!
  account: Account!
  pool: Pool!

  """
  balanceOf(account)
  i.e. the account's staked LP tokens
  
  """
  balance: BigInt!

  """
  rewards(account)
  
  """
  rewards: BigInt!

  """
  userRewardPerTokenPaid(account)
  
  """
  rewardPerTokenPaid: BigInt!
}

input PoolAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  rewards: BigInt
  rewards_not: BigInt
  rewards_gt: BigInt
  rewards_lt: BigInt
  rewards_gte: BigInt
  rewards_lte: BigInt
  rewards_in: [BigInt!]
  rewards_not_in: [BigInt!]
  rewardPerTokenPaid: BigInt
  rewardPerTokenPaid_not: BigInt
  rewardPerTokenPaid_gt: BigInt
  rewardPerTokenPaid_lt: BigInt
  rewardPerTokenPaid_gte: BigInt
  rewardPerTokenPaid_lte: BigInt
  rewardPerTokenPaid_in: [BigInt!]
  rewardPerTokenPaid_not_in: [BigInt!]
}

enum PoolAccount_orderBy {
  id
  account
  pool
  balance
  rewards
  rewardPerTokenPaid
}

type PoolRewardData implements IRewardData {
  """
  {pool.id}.{token.id}
  
  """
  id: ID!
  token: Token!
  periodFinish: Int!
  lastUpdateTime: Int!
  rewardRate: BigInt!
  rewardPerTokenStored: BigInt!
  pool: Pool!
}

input PoolRewardData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  periodFinish: Int
  periodFinish_not: Int
  periodFinish_gt: Int
  periodFinish_lt: Int
  periodFinish_gte: Int
  periodFinish_lte: Int
  periodFinish_in: [Int!]
  periodFinish_not_in: [Int!]
  lastUpdateTime: Int
  lastUpdateTime_not: Int
  lastUpdateTime_gt: Int
  lastUpdateTime_lt: Int
  lastUpdateTime_gte: Int
  lastUpdateTime_lte: Int
  lastUpdateTime_in: [Int!]
  lastUpdateTime_not_in: [Int!]
  rewardRate: BigInt
  rewardRate_not: BigInt
  rewardRate_gt: BigInt
  rewardRate_lt: BigInt
  rewardRate_gte: BigInt
  rewardRate_lte: BigInt
  rewardRate_in: [BigInt!]
  rewardRate_not_in: [BigInt!]
  rewardPerTokenStored: BigInt
  rewardPerTokenStored_not: BigInt
  rewardPerTokenStored_gt: BigInt
  rewardPerTokenStored_lt: BigInt
  rewardPerTokenStored_gte: BigInt
  rewardPerTokenStored_lte: BigInt
  rewardPerTokenStored_in: [BigInt!]
  rewardPerTokenStored_not_in: [BigInt!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
}

enum PoolRewardData_orderBy {
  id
  token
  periodFinish
  lastUpdateTime
  rewardRate
  rewardPerTokenStored
  pool
}

type Query {
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  cvxLockerAccount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxLockerAccount
  cvxLockerAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxLockerAccount_orderBy
    orderDirection: OrderDirection
    where: CvxLockerAccount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxLockerAccount!]!
  cvxLockerUserLock(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxLockerUserLock
  cvxLockerUserLocks(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxLockerUserLock_orderBy
    orderDirection: OrderDirection
    where: CvxLockerUserLock_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxLockerUserLock!]!
  cvxLockerUserData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxLockerUserData
  cvxLockerUserDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxLockerUserData_orderBy
    orderDirection: OrderDirection
    where: CvxLockerUserData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxLockerUserData!]!
  poolAccount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolAccount
  poolAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    where: PoolAccount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolAccount!]!
  poolRewardData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardData
  poolRewardDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolRewardData_orderBy
    orderDirection: OrderDirection
    where: PoolRewardData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolRewardData!]!
  pool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  factoryPoolData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FactoryPoolData
  factoryPoolDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: FactoryPoolData_orderBy
    orderDirection: OrderDirection
    where: FactoryPoolData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FactoryPoolData!]!
  cvxCrvPoolData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxCrvPoolData
  cvxCrvPoolDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxCrvPoolData_orderBy
    orderDirection: OrderDirection
    where: CvxCrvPoolData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxCrvPoolData!]!
  auraLocker(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLocker
  auraLockers(
    skip: Int = 0
    first: Int = 100
    orderBy: AuraLocker_orderBy
    orderDirection: OrderDirection
    where: AuraLocker_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuraLocker!]!
  auraLockerRewardData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerRewardData
  auraLockerRewardDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: AuraLockerRewardData_orderBy
    orderDirection: OrderDirection
    where: AuraLockerRewardData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuraLockerRewardData!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  irewardData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IRewardData
  irewardDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: IRewardData_orderBy
    orderDirection: OrderDirection
    where: IRewardData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IRewardData!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  cvxLockerAccount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxLockerAccount
  cvxLockerAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxLockerAccount_orderBy
    orderDirection: OrderDirection
    where: CvxLockerAccount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxLockerAccount!]!
  cvxLockerUserLock(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxLockerUserLock
  cvxLockerUserLocks(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxLockerUserLock_orderBy
    orderDirection: OrderDirection
    where: CvxLockerUserLock_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxLockerUserLock!]!
  cvxLockerUserData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxLockerUserData
  cvxLockerUserDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxLockerUserData_orderBy
    orderDirection: OrderDirection
    where: CvxLockerUserData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxLockerUserData!]!
  poolAccount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolAccount
  poolAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolAccount_orderBy
    orderDirection: OrderDirection
    where: PoolAccount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolAccount!]!
  poolRewardData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolRewardData
  poolRewardDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolRewardData_orderBy
    orderDirection: OrderDirection
    where: PoolRewardData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolRewardData!]!
  pool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  factoryPoolData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FactoryPoolData
  factoryPoolDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: FactoryPoolData_orderBy
    orderDirection: OrderDirection
    where: FactoryPoolData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FactoryPoolData!]!
  cvxCrvPoolData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CvxCrvPoolData
  cvxCrvPoolDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: CvxCrvPoolData_orderBy
    orderDirection: OrderDirection
    where: CvxCrvPoolData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CvxCrvPoolData!]!
  auraLocker(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLocker
  auraLockers(
    skip: Int = 0
    first: Int = 100
    orderBy: AuraLocker_orderBy
    orderDirection: OrderDirection
    where: AuraLocker_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuraLocker!]!
  auraLockerRewardData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuraLockerRewardData
  auraLockerRewardDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: AuraLockerRewardData_orderBy
    orderDirection: OrderDirection
    where: AuraLockerRewardData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuraLockerRewardData!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  irewardData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IRewardData
  irewardDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: IRewardData_orderBy
    orderDirection: OrderDirection
    where: IRewardData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IRewardData!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  """
  Address
  
  """
  id: ID!
  decimals: Int!
  symbol: String!
  name: String!
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
}

enum Token_orderBy {
  id
  decimals
  symbol
  name
}

