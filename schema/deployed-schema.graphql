# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

interface RewardData {
    """

    Last time any user took action
    """
    lastUpdateTime: Int!
    """

    Timestamp for current period finish
    """
    periodFinish: Int!
    """

    Ever increasing rewardPerToken rate, based on % of total supply
    """
    rewardPerTokenStored: BigInt!
    """

    RewardRate for the rest of the period
    """
    rewardRate: BigInt!
    token: Token!
}

type Account {
    auraLockerAccount: AuraLockerAccount
    """

    Address
    """
    id: ID!
    poolAccounts(first: Int = 100, orderBy: PoolAccount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolAccount_filter): [PoolAccount!]!
}

type AuraBalPoolData {
    """

    Singleton: "auraBal"
    """
    id: ID!
    maxSupply: BigInt!
    pool: Pool!
    reductionPerCliff: BigInt!
    totalCliffs: BigInt!
}

type AuraLocker {
    accounts(first: Int = 100, orderBy: AuraLockerAccount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerAccount_filter): [AuraLockerAccount!]!
    address: Bytes!
    """

    Singleton: "AuraLocker"
    """
    id: ID!
    rewardData(first: Int = 100, orderBy: AuraLockerRewardData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerRewardData_filter): [AuraLockerRewardData!]!
}

type AuraLockerAccount {
    account: Account!
    auraLocker: AuraLocker!
    balance: BigInt!
    """

    AuraLocker.balances(account)
    """
    balanceLocked: BigInt!
    balanceNextUnlockIndex: Int!
    """

    {Account.id}
    """
    id: ID!
    lastUpdateTime: Int!
    """

    AuraLocker.rewardData(account)
    """
    periodFinish: Int!
    rewardPerTokenPaid: BigInt!
    rewardRate: BigInt!
    """

    AuraLocker.userData(account)
    """
    userData(first: Int = 100, orderBy: AuraLockerUserData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerUserData_filter): [AuraLockerUserData!]!
    """

    AuraLocker.userLocks(account)
    """
    userLocks(first: Int = 100, orderBy: AuraLockerUserLock_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AuraLockerUserLock_filter): [AuraLockerUserLock!]!
}

type AuraLockerRewardData implements RewardData {
    auraLocker: AuraLocker!
    """

    {token.id}
    """
    id: ID!
    lastUpdateTime: Int!
    periodFinish: Int!
    rewardPerTokenStored: BigInt!
    rewardRate: BigInt!
    token: Token!
}

type AuraLockerUserData {
    auraLockerAccount: AuraLockerAccount!
    """

    {AuraLockerAccount.id}.{Token.id}
    """
    id: ID!
    rewardPerTokenPaid: BigInt!
    rewards: BigInt!
    token: ID!
}

type AuraLockerUserLock {
    amount: BigInt!
    auraLockerAccount: AuraLockerAccount!
    """

    {AuraLockerAccount.id}.{index}
    """
    id: ID!
    unlockTime: Int!
}

type FactoryPoolData {
    gauge: Bytes!
    """

    {pool.id}
    """
    id: ID!
    isShutdown: Boolean!
    lpToken: Token!
    pool: Pool!
    stash: Bytes!
}

type Pool {
    accounts(first: Int = 100, orderBy: PoolAccount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolAccount_filter): [PoolAccount!]!
    depositToken: Token!
    factoryPoolData: FactoryPoolData
    """

    Pool ID (pid)
    """
    id: ID!
    rewardData(first: Int = 100, orderBy: PoolRewardData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PoolRewardData_filter): [PoolRewardData!]!
    rewardPool: Bytes!
    totalSupply: BigInt!
}

type PoolAccount {
    account: Account!
    """

    balanceOf(account)
    i.e. the account's staked LP tokens
    """
    balance: BigInt!
    """

    {Pool.id}.{Account.id}
    """
    id: ID!
    pool: Pool!
    """

    userRewardPerTokenPaid(account)
    """
    rewardPerTokenPaid: BigInt!
    """

    rewards(account)
    """
    rewards: BigInt!
}

type PoolRewardData implements RewardData {
    """

    {pool.id}.{token.id}
    """
    id: ID!
    lastUpdateTime: Int!
    periodFinish: Int!
    pool: Pool!
    rewardPerTokenStored: BigInt!
    rewardRate: BigInt!
    token: Token!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    auraBalPoolData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraBalPoolData
    auraBalPoolDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraBalPoolData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraBalPoolData_filter
    ): [AuraBalPoolData!]!
    auraLocker(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLocker
    auraLockerAccount(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerAccount
    auraLockerAccounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerAccount_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerAccount_filter
    ): [AuraLockerAccount!]!
    auraLockerRewardData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerRewardData
    auraLockerRewardDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerRewardData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerRewardData_filter
    ): [AuraLockerRewardData!]!
    auraLockerUserData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerUserData
    auraLockerUserDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerUserData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerUserData_filter
    ): [AuraLockerUserData!]!
    auraLockerUserLock(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerUserLock
    auraLockerUserLocks(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerUserLock_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerUserLock_filter
    ): [AuraLockerUserLock!]!
    auraLockers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLocker_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLocker_filter
    ): [AuraLocker!]!
    factoryPoolData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FactoryPoolData
    factoryPoolDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FactoryPoolData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FactoryPoolData_filter
    ): [FactoryPoolData!]!
    pool(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolAccount(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolAccount
    poolAccounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PoolAccount_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PoolAccount_filter
    ): [PoolAccount!]!
    poolRewardData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolRewardData
    poolRewardDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PoolRewardData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PoolRewardData_filter
    ): [PoolRewardData!]!
    pools(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Pool_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Pool_filter
    ): [Pool!]!
    rewardData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardData
    rewardDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RewardData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RewardData_filter
    ): [RewardData!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    auraBalPoolData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraBalPoolData
    auraBalPoolDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraBalPoolData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraBalPoolData_filter
    ): [AuraBalPoolData!]!
    auraLocker(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLocker
    auraLockerAccount(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerAccount
    auraLockerAccounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerAccount_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerAccount_filter
    ): [AuraLockerAccount!]!
    auraLockerRewardData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerRewardData
    auraLockerRewardDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerRewardData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerRewardData_filter
    ): [AuraLockerRewardData!]!
    auraLockerUserData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerUserData
    auraLockerUserDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerUserData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerUserData_filter
    ): [AuraLockerUserData!]!
    auraLockerUserLock(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AuraLockerUserLock
    auraLockerUserLocks(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLockerUserLock_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLockerUserLock_filter
    ): [AuraLockerUserLock!]!
    auraLockers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AuraLocker_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AuraLocker_filter
    ): [AuraLocker!]!
    factoryPoolData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FactoryPoolData
    factoryPoolDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FactoryPoolData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FactoryPoolData_filter
    ): [FactoryPoolData!]!
    pool(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolAccount(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolAccount
    poolAccounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PoolAccount_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PoolAccount_filter
    ): [PoolAccount!]!
    poolRewardData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolRewardData
    poolRewardDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PoolRewardData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PoolRewardData_filter
    ): [PoolRewardData!]!
    pools(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Pool_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Pool_filter
    ): [Pool!]!
    rewardData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardData
    rewardDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RewardData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RewardData_filter
    ): [RewardData!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
}

type Token {
    decimals: Int!
    """

    Address
    """
    id: ID!
    name: String!
    symbol: String!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum Account_orderBy {
    auraLockerAccount
    id
    poolAccounts
}

enum AuraBalPoolData_orderBy {
    id
    maxSupply
    pool
    reductionPerCliff
    totalCliffs
}

enum AuraLockerAccount_orderBy {
    account
    auraLocker
    balance
    balanceLocked
    balanceNextUnlockIndex
    id
    lastUpdateTime
    periodFinish
    rewardPerTokenPaid
    rewardRate
    userData
    userLocks
}

enum AuraLockerRewardData_orderBy {
    auraLocker
    id
    lastUpdateTime
    periodFinish
    rewardPerTokenStored
    rewardRate
    token
}

enum AuraLockerUserData_orderBy {
    auraLockerAccount
    id
    rewardPerTokenPaid
    rewards
    token
}

enum AuraLockerUserLock_orderBy {
    amount
    auraLockerAccount
    id
    unlockTime
}

enum AuraLocker_orderBy {
    accounts
    address
    id
    rewardData
}

enum FactoryPoolData_orderBy {
    gauge
    id
    isShutdown
    lpToken
    pool
    stash
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum PoolAccount_orderBy {
    account
    balance
    id
    pool
    rewardPerTokenPaid
    rewards
}

enum PoolRewardData_orderBy {
    id
    lastUpdateTime
    periodFinish
    pool
    rewardPerTokenStored
    rewardRate
    token
}

enum Pool_orderBy {
    accounts
    depositToken
    factoryPoolData
    id
    rewardData
    rewardPool
    totalSupply
}

enum RewardData_orderBy {
    lastUpdateTime
    periodFinish
    rewardPerTokenStored
    rewardRate
    token
}

enum Token_orderBy {
    decimals
    id
    name
    symbol
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input Account_filter {
    auraLockerAccount: String
    auraLockerAccount_contains: String
    auraLockerAccount_contains_nocase: String
    auraLockerAccount_ends_with: String
    auraLockerAccount_ends_with_nocase: String
    auraLockerAccount_gt: String
    auraLockerAccount_gte: String
    auraLockerAccount_in: [String!]
    auraLockerAccount_lt: String
    auraLockerAccount_lte: String
    auraLockerAccount_not: String
    auraLockerAccount_not_contains: String
    auraLockerAccount_not_contains_nocase: String
    auraLockerAccount_not_ends_with: String
    auraLockerAccount_not_ends_with_nocase: String
    auraLockerAccount_not_in: [String!]
    auraLockerAccount_not_starts_with: String
    auraLockerAccount_not_starts_with_nocase: String
    auraLockerAccount_starts_with: String
    auraLockerAccount_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

input AuraBalPoolData_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    maxSupply: BigInt
    maxSupply_gt: BigInt
    maxSupply_gte: BigInt
    maxSupply_in: [BigInt!]
    maxSupply_lt: BigInt
    maxSupply_lte: BigInt
    maxSupply_not: BigInt
    maxSupply_not_in: [BigInt!]
    pool: String
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    reductionPerCliff: BigInt
    reductionPerCliff_gt: BigInt
    reductionPerCliff_gte: BigInt
    reductionPerCliff_in: [BigInt!]
    reductionPerCliff_lt: BigInt
    reductionPerCliff_lte: BigInt
    reductionPerCliff_not: BigInt
    reductionPerCliff_not_in: [BigInt!]
    totalCliffs: BigInt
    totalCliffs_gt: BigInt
    totalCliffs_gte: BigInt
    totalCliffs_in: [BigInt!]
    totalCliffs_lt: BigInt
    totalCliffs_lte: BigInt
    totalCliffs_not: BigInt
    totalCliffs_not_in: [BigInt!]
}

input AuraLockerAccount_filter {
    account: String
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    auraLocker: String
    auraLocker_contains: String
    auraLocker_contains_nocase: String
    auraLocker_ends_with: String
    auraLocker_ends_with_nocase: String
    auraLocker_gt: String
    auraLocker_gte: String
    auraLocker_in: [String!]
    auraLocker_lt: String
    auraLocker_lte: String
    auraLocker_not: String
    auraLocker_not_contains: String
    auraLocker_not_contains_nocase: String
    auraLocker_not_ends_with: String
    auraLocker_not_ends_with_nocase: String
    auraLocker_not_in: [String!]
    auraLocker_not_starts_with: String
    auraLocker_not_starts_with_nocase: String
    auraLocker_starts_with: String
    auraLocker_starts_with_nocase: String
    balance: BigInt
    balanceLocked: BigInt
    balanceLocked_gt: BigInt
    balanceLocked_gte: BigInt
    balanceLocked_in: [BigInt!]
    balanceLocked_lt: BigInt
    balanceLocked_lte: BigInt
    balanceLocked_not: BigInt
    balanceLocked_not_in: [BigInt!]
    balanceNextUnlockIndex: Int
    balanceNextUnlockIndex_gt: Int
    balanceNextUnlockIndex_gte: Int
    balanceNextUnlockIndex_in: [Int!]
    balanceNextUnlockIndex_lt: Int
    balanceNextUnlockIndex_lte: Int
    balanceNextUnlockIndex_not: Int
    balanceNextUnlockIndex_not_in: [Int!]
    balance_gt: BigInt
    balance_gte: BigInt
    balance_in: [BigInt!]
    balance_lt: BigInt
    balance_lte: BigInt
    balance_not: BigInt
    balance_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lastUpdateTime: Int
    lastUpdateTime_gt: Int
    lastUpdateTime_gte: Int
    lastUpdateTime_in: [Int!]
    lastUpdateTime_lt: Int
    lastUpdateTime_lte: Int
    lastUpdateTime_not: Int
    lastUpdateTime_not_in: [Int!]
    periodFinish: Int
    periodFinish_gt: Int
    periodFinish_gte: Int
    periodFinish_in: [Int!]
    periodFinish_lt: Int
    periodFinish_lte: Int
    periodFinish_not: Int
    periodFinish_not_in: [Int!]
    rewardPerTokenPaid: BigInt
    rewardPerTokenPaid_gt: BigInt
    rewardPerTokenPaid_gte: BigInt
    rewardPerTokenPaid_in: [BigInt!]
    rewardPerTokenPaid_lt: BigInt
    rewardPerTokenPaid_lte: BigInt
    rewardPerTokenPaid_not: BigInt
    rewardPerTokenPaid_not_in: [BigInt!]
    rewardRate: BigInt
    rewardRate_gt: BigInt
    rewardRate_gte: BigInt
    rewardRate_in: [BigInt!]
    rewardRate_lt: BigInt
    rewardRate_lte: BigInt
    rewardRate_not: BigInt
    rewardRate_not_in: [BigInt!]
}

input AuraLockerRewardData_filter {
    auraLocker: String
    auraLocker_contains: String
    auraLocker_contains_nocase: String
    auraLocker_ends_with: String
    auraLocker_ends_with_nocase: String
    auraLocker_gt: String
    auraLocker_gte: String
    auraLocker_in: [String!]
    auraLocker_lt: String
    auraLocker_lte: String
    auraLocker_not: String
    auraLocker_not_contains: String
    auraLocker_not_contains_nocase: String
    auraLocker_not_ends_with: String
    auraLocker_not_ends_with_nocase: String
    auraLocker_not_in: [String!]
    auraLocker_not_starts_with: String
    auraLocker_not_starts_with_nocase: String
    auraLocker_starts_with: String
    auraLocker_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lastUpdateTime: Int
    lastUpdateTime_gt: Int
    lastUpdateTime_gte: Int
    lastUpdateTime_in: [Int!]
    lastUpdateTime_lt: Int
    lastUpdateTime_lte: Int
    lastUpdateTime_not: Int
    lastUpdateTime_not_in: [Int!]
    periodFinish: Int
    periodFinish_gt: Int
    periodFinish_gte: Int
    periodFinish_in: [Int!]
    periodFinish_lt: Int
    periodFinish_lte: Int
    periodFinish_not: Int
    periodFinish_not_in: [Int!]
    rewardPerTokenStored: BigInt
    rewardPerTokenStored_gt: BigInt
    rewardPerTokenStored_gte: BigInt
    rewardPerTokenStored_in: [BigInt!]
    rewardPerTokenStored_lt: BigInt
    rewardPerTokenStored_lte: BigInt
    rewardPerTokenStored_not: BigInt
    rewardPerTokenStored_not_in: [BigInt!]
    rewardRate: BigInt
    rewardRate_gt: BigInt
    rewardRate_gte: BigInt
    rewardRate_in: [BigInt!]
    rewardRate_lt: BigInt
    rewardRate_lte: BigInt
    rewardRate_not: BigInt
    rewardRate_not_in: [BigInt!]
    token: String
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input AuraLockerUserData_filter {
    auraLockerAccount: String
    auraLockerAccount_contains: String
    auraLockerAccount_contains_nocase: String
    auraLockerAccount_ends_with: String
    auraLockerAccount_ends_with_nocase: String
    auraLockerAccount_gt: String
    auraLockerAccount_gte: String
    auraLockerAccount_in: [String!]
    auraLockerAccount_lt: String
    auraLockerAccount_lte: String
    auraLockerAccount_not: String
    auraLockerAccount_not_contains: String
    auraLockerAccount_not_contains_nocase: String
    auraLockerAccount_not_ends_with: String
    auraLockerAccount_not_ends_with_nocase: String
    auraLockerAccount_not_in: [String!]
    auraLockerAccount_not_starts_with: String
    auraLockerAccount_not_starts_with_nocase: String
    auraLockerAccount_starts_with: String
    auraLockerAccount_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    rewardPerTokenPaid: BigInt
    rewardPerTokenPaid_gt: BigInt
    rewardPerTokenPaid_gte: BigInt
    rewardPerTokenPaid_in: [BigInt!]
    rewardPerTokenPaid_lt: BigInt
    rewardPerTokenPaid_lte: BigInt
    rewardPerTokenPaid_not: BigInt
    rewardPerTokenPaid_not_in: [BigInt!]
    rewards: BigInt
    rewards_gt: BigInt
    rewards_gte: BigInt
    rewards_in: [BigInt!]
    rewards_lt: BigInt
    rewards_lte: BigInt
    rewards_not: BigInt
    rewards_not_in: [BigInt!]
    token: ID
    token_gt: ID
    token_gte: ID
    token_in: [ID!]
    token_lt: ID
    token_lte: ID
    token_not: ID
    token_not_in: [ID!]
}

input AuraLockerUserLock_filter {
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    auraLockerAccount: String
    auraLockerAccount_contains: String
    auraLockerAccount_contains_nocase: String
    auraLockerAccount_ends_with: String
    auraLockerAccount_ends_with_nocase: String
    auraLockerAccount_gt: String
    auraLockerAccount_gte: String
    auraLockerAccount_in: [String!]
    auraLockerAccount_lt: String
    auraLockerAccount_lte: String
    auraLockerAccount_not: String
    auraLockerAccount_not_contains: String
    auraLockerAccount_not_contains_nocase: String
    auraLockerAccount_not_ends_with: String
    auraLockerAccount_not_ends_with_nocase: String
    auraLockerAccount_not_in: [String!]
    auraLockerAccount_not_starts_with: String
    auraLockerAccount_not_starts_with_nocase: String
    auraLockerAccount_starts_with: String
    auraLockerAccount_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    unlockTime: Int
    unlockTime_gt: Int
    unlockTime_gte: Int
    unlockTime_in: [Int!]
    unlockTime_lt: Int
    unlockTime_lte: Int
    unlockTime_not: Int
    unlockTime_not_in: [Int!]
}

input AuraLocker_filter {
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

"The block at which the query should be executed."
input Block_height {
    "Value containing a block hash"
    hash: Bytes
    "Value containing a block number"
    number: Int
    """

    Value containing the minimum block number.
    In the case of `number_gte`, the query will be executed on the latest block only if
    the subgraph has progressed to or past the minimum block number.
    Defaults to the latest block when omitted.
    """
    number_gte: Int
}

input FactoryPoolData_filter {
    gauge: Bytes
    gauge_contains: Bytes
    gauge_in: [Bytes!]
    gauge_not: Bytes
    gauge_not_contains: Bytes
    gauge_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isShutdown: Boolean
    isShutdown_in: [Boolean!]
    isShutdown_not: Boolean
    isShutdown_not_in: [Boolean!]
    lpToken: String
    lpToken_contains: String
    lpToken_contains_nocase: String
    lpToken_ends_with: String
    lpToken_ends_with_nocase: String
    lpToken_gt: String
    lpToken_gte: String
    lpToken_in: [String!]
    lpToken_lt: String
    lpToken_lte: String
    lpToken_not: String
    lpToken_not_contains: String
    lpToken_not_contains_nocase: String
    lpToken_not_ends_with: String
    lpToken_not_ends_with_nocase: String
    lpToken_not_in: [String!]
    lpToken_not_starts_with: String
    lpToken_not_starts_with_nocase: String
    lpToken_starts_with: String
    lpToken_starts_with_nocase: String
    pool: String
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    stash: Bytes
    stash_contains: Bytes
    stash_in: [Bytes!]
    stash_not: Bytes
    stash_not_contains: Bytes
    stash_not_in: [Bytes!]
}

input PoolAccount_filter {
    account: String
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    balance: BigInt
    balance_gt: BigInt
    balance_gte: BigInt
    balance_in: [BigInt!]
    balance_lt: BigInt
    balance_lte: BigInt
    balance_not: BigInt
    balance_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    pool: String
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    rewardPerTokenPaid: BigInt
    rewardPerTokenPaid_gt: BigInt
    rewardPerTokenPaid_gte: BigInt
    rewardPerTokenPaid_in: [BigInt!]
    rewardPerTokenPaid_lt: BigInt
    rewardPerTokenPaid_lte: BigInt
    rewardPerTokenPaid_not: BigInt
    rewardPerTokenPaid_not_in: [BigInt!]
    rewards: BigInt
    rewards_gt: BigInt
    rewards_gte: BigInt
    rewards_in: [BigInt!]
    rewards_lt: BigInt
    rewards_lte: BigInt
    rewards_not: BigInt
    rewards_not_in: [BigInt!]
}

input PoolRewardData_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lastUpdateTime: Int
    lastUpdateTime_gt: Int
    lastUpdateTime_gte: Int
    lastUpdateTime_in: [Int!]
    lastUpdateTime_lt: Int
    lastUpdateTime_lte: Int
    lastUpdateTime_not: Int
    lastUpdateTime_not_in: [Int!]
    periodFinish: Int
    periodFinish_gt: Int
    periodFinish_gte: Int
    periodFinish_in: [Int!]
    periodFinish_lt: Int
    periodFinish_lte: Int
    periodFinish_not: Int
    periodFinish_not_in: [Int!]
    pool: String
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    rewardPerTokenStored: BigInt
    rewardPerTokenStored_gt: BigInt
    rewardPerTokenStored_gte: BigInt
    rewardPerTokenStored_in: [BigInt!]
    rewardPerTokenStored_lt: BigInt
    rewardPerTokenStored_lte: BigInt
    rewardPerTokenStored_not: BigInt
    rewardPerTokenStored_not_in: [BigInt!]
    rewardRate: BigInt
    rewardRate_gt: BigInt
    rewardRate_gte: BigInt
    rewardRate_in: [BigInt!]
    rewardRate_lt: BigInt
    rewardRate_lte: BigInt
    rewardRate_not: BigInt
    rewardRate_not_in: [BigInt!]
    token: String
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input Pool_filter {
    depositToken: String
    depositToken_contains: String
    depositToken_contains_nocase: String
    depositToken_ends_with: String
    depositToken_ends_with_nocase: String
    depositToken_gt: String
    depositToken_gte: String
    depositToken_in: [String!]
    depositToken_lt: String
    depositToken_lte: String
    depositToken_not: String
    depositToken_not_contains: String
    depositToken_not_contains_nocase: String
    depositToken_not_ends_with: String
    depositToken_not_ends_with_nocase: String
    depositToken_not_in: [String!]
    depositToken_not_starts_with: String
    depositToken_not_starts_with_nocase: String
    depositToken_starts_with: String
    depositToken_starts_with_nocase: String
    factoryPoolData: String
    factoryPoolData_contains: String
    factoryPoolData_contains_nocase: String
    factoryPoolData_ends_with: String
    factoryPoolData_ends_with_nocase: String
    factoryPoolData_gt: String
    factoryPoolData_gte: String
    factoryPoolData_in: [String!]
    factoryPoolData_lt: String
    factoryPoolData_lte: String
    factoryPoolData_not: String
    factoryPoolData_not_contains: String
    factoryPoolData_not_contains_nocase: String
    factoryPoolData_not_ends_with: String
    factoryPoolData_not_ends_with_nocase: String
    factoryPoolData_not_in: [String!]
    factoryPoolData_not_starts_with: String
    factoryPoolData_not_starts_with_nocase: String
    factoryPoolData_starts_with: String
    factoryPoolData_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    rewardPool: Bytes
    rewardPool_contains: Bytes
    rewardPool_in: [Bytes!]
    rewardPool_not: Bytes
    rewardPool_not_contains: Bytes
    rewardPool_not_in: [Bytes!]
    totalSupply: BigInt
    totalSupply_gt: BigInt
    totalSupply_gte: BigInt
    totalSupply_in: [BigInt!]
    totalSupply_lt: BigInt
    totalSupply_lte: BigInt
    totalSupply_not: BigInt
    totalSupply_not_in: [BigInt!]
}

input RewardData_filter {
    lastUpdateTime: Int
    lastUpdateTime_gt: Int
    lastUpdateTime_gte: Int
    lastUpdateTime_in: [Int!]
    lastUpdateTime_lt: Int
    lastUpdateTime_lte: Int
    lastUpdateTime_not: Int
    lastUpdateTime_not_in: [Int!]
    periodFinish: Int
    periodFinish_gt: Int
    periodFinish_gte: Int
    periodFinish_in: [Int!]
    periodFinish_lt: Int
    periodFinish_lte: Int
    periodFinish_not: Int
    periodFinish_not_in: [Int!]
    rewardPerTokenStored: BigInt
    rewardPerTokenStored_gt: BigInt
    rewardPerTokenStored_gte: BigInt
    rewardPerTokenStored_in: [BigInt!]
    rewardPerTokenStored_lt: BigInt
    rewardPerTokenStored_lte: BigInt
    rewardPerTokenStored_not: BigInt
    rewardPerTokenStored_not_in: [BigInt!]
    rewardRate: BigInt
    rewardRate_gt: BigInt
    rewardRate_gte: BigInt
    rewardRate_in: [BigInt!]
    rewardRate_lt: BigInt
    rewardRate_lte: BigInt
    rewardRate_not: BigInt
    rewardRate_not_in: [BigInt!]
    token: String
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input Token_filter {
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
}
